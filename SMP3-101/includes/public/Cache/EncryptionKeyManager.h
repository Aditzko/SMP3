//
//  EncryptionKeyManager.h
//  Cache
//
//  Created by i061647 on 7/30/13.
//  Copyright (c) 2013 M, Pramod. All rights reserved.
//

#import <Foundation/Foundation.h>

NSString* const kCacheDbResetNotification;
NSString* const kNilOrEmptyEncryptionKey;

//The Encryption key has been already generated but not being passed from the application
#define _keyAlreadyGeneratedError 5000

#define _keyIsNotCorrect 5002
/**
 * @brief The class EncryptionKeyManager provides a way to enforce security mechanism at the mobile client, basically for the persistence core for
 * Cache and queue of requests. This class creates and deletes the database with the use of a unique 128-bit encryption key that has to be
 * stored for future operations by either the Mobile Application Framework (MAF) or by the application itself.
 */
@interface EncryptionKeyManager : NSObject
/**
 * @brief This method should not be used by the application developer or the MAF as this is only intended for internal usage. If used outside, could
 * give unexpected results. Please Don't use this API.
 */
+(NSString *)encryptionKey;

/**
 * @brief A static method to provide the unique 128-bit encryption key. This method should be called at the first invocation of the application
 * to fetch the unique key for the newly created encrypted Database.
 *
 * @param error NSError* object to capture any error if occured during the execution of the method.
 * @return Returns NSString* a unique 128-bit key to be used for the subsequent operation on DB.
 * <pre>
 * Usage
 * <code>
 *
 * NSError *error= nil;
 * NSString *key = [EncryptionKeyManager getEncryptionKey:&error];
 * if(error!=nil){
 *    NSLog(@"Error %@",[error description]);
 * }
 * -- Persist the key into the Datavault or Other persistence place
 *
 * </code>
 * </pre>
 */
+(NSString *) getEncryptionKey:(NSError **)error;

/**
 * @brief A static method to set the unique 128-bit encryption key back to the code to perform the DB operations. This should only be called if
 * the key exists in the vault. When passing key as null, the key will be cleared from the memory and no further operations could be possible.
 * If the key is wrong i.e. not the one which was used for DB encryption, again no operation could be possible further until the correct key has
 * been set.
 *
 * @param key NSString* takes a unique 128-bit encryption key which was eariler generated by getEncryptionKey and saved by the MAF or Application
 * at the first invocation of the application.
 * @param error NSError* object to capture any error if occured during the execution of the method.
 * <pre>
 * Usage
 * <code>
 *
 * -- Obtain the key from the Datavault or Other persistence place and pass it to the function below
 * NSError *error= nil;
 * [EncryptionKeyManager setEncryptionKey: key withError: &error];
 * if(error!=nil){
 *    NSLog(@"Error %@",[error description]);
 * }
 * </code>
 * </pre>
 */
+(void) setEncryptionKey:(NSString *) key withError:(NSError **)error;

+(void) setEncryptionKey:(NSString *)key __attribute__((deprecated));
/**
 * @brief A static method to regenerate the key along with the database i.e. by calling this method the DB that exists on the mobile client will be
 * removed and a new DB with a newly created unique 128-bit encryption key will be generated. After the invocation of this method the newly generated
 * key should be stored by the MAF or application again by removing the old key.
 *
 * @return NSString* it returns a newly created 128-bit encryption key.
 * <pre>
 * Usage
 * <code>
 *
 * NSString *newKey = [EncryptionKeyManager resetEncryptionKey];
 * -- Persist this newKey into the Datavault or other persistence place, while removing the existing key if exists.
 *
 * </code>
 * </pre>
 */
+(NSString *) resetEncryptionKey;

@end

